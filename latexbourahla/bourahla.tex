\documentclass{article}
\usepackage{forest}
\begin{document}

\section*{exercice n01:}
    \subsection*{a) Les sources du probl`eme d’apprentissage}
    \begin{enumerate}
        \item nombre de cycles durant lesquels la performance 
        de l’agent reste sous-optimale pour la tâche de décision donnée.
        \item Les ressources de calcul nécessaires durant chaque 
        cycle à l’agent pour réviser sa stratégie et choisir une action.



    \end{enumerate}
    \subsection*{b)   Le modèle d’apprentissage:}
    modèle d’apprentissage est un cadre formel donnant une mesure des deux
    sources de complexitè mentionné prècèdament .
    \subsection*{c) L'influence des observations, les actions et le feedback sur la difficulté de l’apprentissage}
    \begin{enumerate}
    \item  L'observation:
          \begin{itemize}
    
              \item[$\ast$] la dimension peut etre immense, voire infini
              \item[$\ast$]  les valeurs de certains attributs peuvent être imprécises, erronées, ou encore absentes.
              \item[$\ast$]  environnements partiellement observables alors ’une situation incertain
            \end{itemize}
     \item  L'action: les actions sont des decision soit simple ou complex, 
    \begin{itemize}
    
        \item[$\ast$] l’espace des décisions possède une structure combinatoire; les décisions peuvent prendre la forme d’arbres, 
        de graphes, ou encore d’hypergraphes
         \item[$\ast$] Les actions simples peuvent avoir un impact sur la difficulté de 
         l’apprentissage selon la manière dont elles influent l’environnement  (épisodique/séquentiel)
      \end{itemize}
      \item  Feedback:Le type de feedback définit le mode d’apprentissage

     \end{enumerate}
     

\section*{exercice n02}

    \subsection*{les composants du problème d’apprentissage de porte logique XOR}
    la fonction Xor envoi une valeur vraie si les deux entrées ne sont
    pas  ́egaux et  fausse si elles sont  ́egaux
    \begin{itemize}
        \item[$\ast$] l’espace des entrées est le couple (a,b)/ (a,b) $ \in $ X=\{(0, 0),(0, 1),(1,0),(1, 1)\} 
\item[$\ast$] l’espace des sorties est Y = \{true,false\}.
\item[$\ast$] programme Xor en python\\
 def xor(x,y):\\
return bool((x and not y) or (not x and y))\\

print(xor(0,0))\\
print(xor(0,1))\\
print(xor(1,0))\\
print(xor(1,1))\\
\end{itemize}
\section*{exercice n03:}
    \subsection*{x1 \lor x2 \wedge x3 \lor x4}

    \begin{forest}
        [x1, for tree={draw,circle}
           [0] [x2[x3[x4[0][1]][1]][1]]]

        
    \end{forest}
\section*{exercice n04:}
    \subsection*{a) la diff ́erence entre une requˆete d’appartenance et une
    requˆete d’ ́equivalence est}
    \begin{enumerate}
        \item Une requˆete d’appartenance (MQ) associe `a une instance x pos ́ee par
        l’apprenant la r ́eponse oui si h(x) = 1, et non sinon.
        \item Une requˆete d’ ́equivalence (EQ) associe `a une hypoth`ese h pos ́e par
        l’apprenant la r ́eponse oui si h = h, et non sinon
    \end{enumerate}
    \subsection*{b) Si pour toute instance (x1, x2, x3) quelle est l’hypoth`ese
    (le concept) le plus sp ́ecifiqu} est h1((x1,x2,x3)) = x1
    \subsection*{c) Si h(x1,x2,x3) = x1 x2 et la requˆete est h((0,1,1)) =
    0}
    \begin{enumerate}
        \item le type de cette requˆete est requˆete d’appartenance (MQ)
        \item et si h*((0,1,1)) = 1, requˆete d’ ́equivalence (EQ)
        \item Si le contre exemple est (0,1,0) mettre `a jour h. h((0,1,0)) = 1

    \end{enumerate}
\section*{exercice05}
%not solutied
\section*{exercice06}
    \subsection*{la diff ́erence entre le mod`ele agnostique et le mod`ele
    PAC}
    Dans le mod`ele “agnostique”, la distribution D est arbitraire, ce quiimplique
    qu’il n’existe a priori aucune d ́ependance fonctionnelle entre une instance x
    et une d ́ecision y dans un exemple tir ́e dans D. En revanche, dans le mod`ele
    (PAC), nous supposons qu’il existe uned ́ependance fonctionnelle gouvern ́ee
    par une fonction cible

\section*{exercice01}
    \begin{enumerate}
    \item  A[]B = B[]A $\to$ Commutativité
        \item A[]stop = stop[]A = A $\to$ Zéro absorption
    \item  A[](B[]C) = (A[]B)[]C $\to$ Associativité 
        \end{enumerate}
\section*{exercice02}
\section*{exercice03}
    \subsection*{process one [a,b,c] a; (b; stop [] c; stop) endproc}
    \begin{forest}
        [one,for tree={parent anchor=south, child anchor=north, fit=band}
        [a[b[stop]][c[stop]]]]
    \end{forest}
    \subsection*{process two [a,b,c] a; b; stop [] a; c; stop Endproc}
    \begin{forest}
        [two,for tree={parent anchor=south, child anchor=north, fit=band}
        [a[b[stop]]]
        [a[c[stop]]]]
    \end{forest}
    \subsection*{P1 := a; (b; d; stop [] c; stop)}

    \begin{forest}
        [p1,for tree={parent anchor=south, child anchor=north, fit=band}
        [a[b[d[stop]]]
        [c[stop]]]
        ]

    \end{forest}
    
\section*{exercice04}
    \subsection*{Ecrire des spécifications lotos pour les circuits logiques: and, or et 
    xor}
   \subsection*{AND}
    specification circuitlogiqueAND [a,b,c] :noexit \\
    type BIT is \\
        sorts BIT\\
        opns 0 (*! constructor *), \\
            1 (*! constructor *) : -> BIT\\
        and : BIT ,BIT-> BIT\\
        eqns \\
            ofsort BIT \\
            and (0,0) = 0; \\
            and (0,1) = 0; \\
            and (0,1) = 0; \\
            and (1,1) = 1; \\
    endtype\\ 
    behaviour\\ 
        gate_and[a, b, c]\\
    where \\
        process gate_AND[a, b] : noexit :=\\ 
        a ?aa:Bit; b?bb:Bit;  c!and(aa,bb); stop \\
        endproc \\
    endspec\\
    %or
    \subsection*{OR}
    specification circuitlogiqueOR [a,b,c] :noexit \\
    type BIT is \\
        sorts BIT\\
        opns 0 (*! constructor *), \\
            1 (*! constructor *) : -> BIT\\
        or : BIT ,BIT-> BIT\\
        eqns \\
            ofsort BIT \\
            or (0,0) = 0; \\
            or (0,1) = 1; \\
            or (0,1) = 1; \\
            or (1,1) = 1; \\
    endtype\\ 
    behaviour\\ 
        gate_OR[a, b, c]\\
    where \\
        process gate_OR[a, b] : noexit :=\\ 
        a ?aa:Bit; b?bb:Bit;  c!or(aa,bb); stop \\
        endproc \\
    endspec\\
    %xor
    \subsection*{XOR}
    specification circuitlogiqueXOR [a,b,c] :noexit \\
    type BIT is \\
        sorts BIT\\
        opns 0 (*! constructor *), \\
            1 (*! constructor *) : -> BIT\\
        xor : BIT ,BIT-> BIT\\
        eqns \\
            ofsort BIT \\
            and (0,0) = 0; \\
            and (0,1) = 1; \\
            and (0,1) = 1; \\
            and (1,1) = 0; \\
    endtype\\ 
    behaviour\\ 
        gate_XOR[a, b, c]\\
    where \\
        process gate_XOr[a, b] : noexit :=\\ 
        a ?aa:Bit; b?bb:Bit;  c!xor(aa,bb); stop \\
        endproc \\
    endspec\\


\end{document}

